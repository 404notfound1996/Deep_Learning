# 面试

**1.deamon 和depolyment 区别**

deamon 一个节点只能有一个,常用于监控 防火墙

depolyment  常见的业务服务部署 pod控制器



**2.pv和pvc区别**



3.goroute如何监控是否被kill

多个goroutine通过 signal.Notify 注册消息的接收，然后在每个 goroutine 中都可以捕捉到kill的信号



**4.rune**

答: rune类型是Go语言中的一个基本类型，其实就是一个**int32的别名**，主要用于表示一个字符类型大于一个字节小于等于4个字节的情况下，特别是**中文字符。**

比如 你好,世界 byte会打印出 13个byte码值(包含逗号),rune就正常打印出5个码值(包含逗号)

![image-20230314072431651](面试题.assets/image-20230314072431651.png)

![image-20230314072508939](面试题.assets/image-20230314072508939.png)





5.如何排查接口变慢

1.首先第一步 先明确是单个接口变慢 还是 多个服务多个接口都变慢 定位到大的方向,多个服务多个接口变慢,优先考虑系统共有资源问题

2.查看网络状态，延长时丢包率等

3.查看服务器共有资源, cpu 利用率，内存，i/o，磁盘空间,  使用TOP PS 命令等等

4.查看数据库的链接是否过多,是否锁表 事务未提交 锁表,读写性能达到瓶颈等等

5.如果是当个接口变慢,就看接口的整个链路,是哪个环节具体变慢了,并结合代码 具体分析



**6.如何鉴权**

答案:在网关进行鉴权

1.定义了一个全局的拦截器。

2.对不在白名单中的url进行鉴权

3.解析jwt是否有效，如果jwt失效或者不正确，直接返回401

4.如果jwt有效，则解析jwt中的载荷信息用户id和用户名，并将用户id和用户名放到接口的请求头中。



7.Go程序内存突然增大 怎么排查

使用pprof工具进行排查 可能涉及到GC,内存泄漏等



**8.copy 和add 区别 yaml中**

答:copy 是从本地服务器 copy到容器内 (常用)

add  如果是压缩文件,复制进容器的时候会进行解压, 可以使用远程url获取远程文件 不一定要本地文件







**产生死锁的条件，怎么解决死锁**

产生条件:

互斥：
指的是共享资源的互斥。
主要是因为多个线程都想访问同一个共享资源，但是该共享资源在某个时刻只能由一个进程访问。
持有并等待：
某进程持有一些资源并等待另外一些资源，在这一过程中，该进程并不会放弃自己已经持有的资源。
不可剥夺：
某线程持有的资源在其使用完之前不能被其他线程获取，只能由其自己使用完后释放。
环路等待：
两个或多个进程互相持有某些资源，并希望得到对方的资源，也可以说线程获取资源的顺序构成了环形链。

解决死锁:

死锁防止

防止是指在程序运行前就采取措施。
死锁防止主要策略是至少要破坏死锁产生的四个必要条件中的一个。

1.破坏互斥条件

使资源可以同时访问而不是互斥访问。
但是这种方法只适合只读资源，不能在独占性资源上采取。

2.破坏持有和等待条件

采用静态分配的方式，即进程必须在执行前申请所需的全部资源，否则不执行。
但是这种方式会严重降低资源的利用率，因为有些资源时在运行前期使用，而有些是在运行后期才使用的。

3.破坏不可剥夺条件

方法一：占有资源的进程若要申请新资源，必须主动释放已占有的资源。
方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。

4.破坏等待循环条件

给系统所有资源编号，规定进程请求资源需按资源编号顺序进行。



**分布式事务，讲一下两阶段提交，过程中节点故障的影响讨论** 

2PC是一个非常经典的强一致、中心化的原子提交协议

2PC(tow phase commit)两阶段提交。所谓的两个阶段是指：

1. 第一阶段：准备阶段(投票阶段)

   询问是否所有协调者资源均准备完成

2. 第二阶段：提交阶段（执行阶段）。

   2.1 正常执行提交

   2.2异常回滚

   

**数据库的隔离级别**

**1.读未提交**

**2.读已提交**（Read Committed）：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）

**3.可重复读**（Repeatable Read）:这是MySQL InnoDB 引擎的默认事务隔离级别

**4.可串行化**（Serializable）：这是最高的隔离级别



**脏读、幻读是什么** 

**脏读：**事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
**不可重复读：**事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。
**幻读：**幻读是指当事务不独立执行时，插入或者删除另一个事务当前影响的数据而发生的一种类似幻觉的现象。

出现幻读和不可重复读的原因很像，都是在多次操作数据的时候发现结果和原来的不一样了，出现了其他事务干扰的现象。

但是**幻读的偏重点是添加和删除数据**，多次操作数据得到的记录数不一样；不可重复读的偏重点是修改数据，多次读取数据发现数据的值不一样了。



**linux 管道如何实现的** 

管道是[Linux](https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020)中很重要的一种通信方式,是把一个程序的输出直接连接到另一个程序的输入,

其实bash在执行管道的时候，是同时创建左右两个进程，而且只会创建一次，并不是左边进程有输出再去创建右边进程处理。我们日常使用管道，多是左边进程很快结束的那种，对于左边进程是持续输出的情况（比如tail -f,tcpdump），以为是左边每输出一次内容就会去新建一个右边的进程来处理，其实管道右边的进程只会创建一次，他会持续的从管道读取数据并进行处理，



**讲一下 TCP 三次握手，为什么需要三次**



**TCP**：是一个面向连接的、可靠的、基于字节流的传输层协议

面向连接：是指 TCP 是面向客户端和服务器端连接的通讯协议，使用它可以将客户端和服务器端进行连接。

可靠性：是指无论网络环境多差，TCP 都可以保证信息一定能够传递到接收端,当 TCP 意识到丢包了就会控制重发此包，这样就实现了 TCP 的可靠性。

面向字节流：是指 TCP 是以字节流的方式进行数据传输的

UDP：是无连接的、简单的、面向数据报的传输层协议

TCP VS UDP：

●可靠性，TCP 有“状态性”和“可控制性”可以保证消息不重复、按顺序、不丢失的发送和接收，而 UDP 则不能保证消息的可靠性；

●连接，TCP 是面向连接的传输层协议，传输数据前先要建立连接，而 UDP 发送数据之前无需建立连接；

●服务对象，TCP 服务的对象为一对一的双端应用，而 UDP 可以应用于一对一、一对多和多对多的通信场景；

●效率，TCP 的传输效率较低，而 UDP 的传输效率较高；

●流量控制，TCP 有滑动窗口可以用来控制流量，而 UDP 则不具备流量控制的能力；

●报文，TCP 是面向字节流的传输层协议，而 UDP 是面向报文的传输层协议；

●应用场景，TCP 的应用场景是对消息准确性和顺序要求较高的场景，而 UDP 则是应用于对通信效率较高、准确性要求相对较低的场景。



为什么需要3次握手？

1.防止重复连接

三次握手的主要原因是为了防止旧的重复连接引起连接混乱问题。

比如在网络状况比较复杂或者网络状况比较差的情况下，发送方可能会连续发送多次建立连接的请求。如果 TCP 握手的次数只有两次，那么接收方只能选择接受请求或者拒绝接受请求，但它并不清楚这次的请求是正常的请求，还是由于网络环境问题而导致的过期请求，如果是过期请求的话就会造成错误的连接。

所以如果 TCP 是三次握手的话，那么客户端在接收到服务器端 SEQ+1 的消息之后，就可以判断当前的连接是否为历史连接，如果判断为历史连接的话就会发送终止报文（RST）给服务器端终止连接；如果判断当前连接不是历史连接的话就会发送指令给服务器端来建立连接。
2.同步初始化序列化

那么在建立 TCP 连接时就需要同步初始化一个序列号来保证 TCP 的稳定性，因此它需要执行以下过程：

●首先客户端发送一个携带了初始序列号的 SYN 报文给服务器端；

●服务端接收到消息之后会回复一个 ACK 的应答报文，表示客户端的 SYN 报文已被服务端成功接收了；

●而客户端收到消息之后也会发送一个 ACK 给服务端，服务器端拿到这个消息之后，我们就可以得到一个可靠的初始化序列号了。

而如果是两次握手的话，就无法进行序列号的确认工作了，因此也就无法得到一个可靠的序列号了，所以 TCP 连接至少需要三次握手。




**TCP 的 time_wait 状态了解吗？为什么需要该状态？如果 server 端存在大量处于 time_wait 状态的连接，会产生什么影响，该如何优化**

为什么有time_wait 状态？

1.可以保证可靠地终止 TCP 连接，如果处于 TIME_WAIT 的客户端发送给服务器确认报文段丢失的话，服务器将重新发送 FIN 报文段，所以客户端必须处于一个可接收的状态 TIME_WAIT 而不是 CLOSED 状态。

2.可以保证迟来的 TCP 报文段有足够的时间被识别并丢弃，某些情况，TCP 报文可能会延迟到达，为了避免迟到的 TCP 报文被误认为是新 TCP 连接的数据，需要在允许新创建 TCP 连接之前，保持一个不可用的状态，等待所有延迟报文的处理。



time_wait为什么是等待2MSL时间？

**MSL**（Maximum Segment Lifetime）是 TCP 协议数据报中任意一段数据在网络上被丢弃之前保持可用的最大时间

相当于至少允许报文丢失一次。比如，若 A**CK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。



存在大量处于 time_wait 状态的连接，会产生什么影响？

1.客户端受端口资源限制：如果客户端 TIME_WAIT 过多，就会导致端口资源被占用，因为端口就 65536 个，被占满就会导致无法创建新的连接。

2.服务端受系统资源限制：理论上服务端可以建立很多连接，虽然只需监听一个端口但会把连接扔给处理线程，所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。



如何优化？

调整短连接为长连接



go 中有缓冲 channel 和无缓冲 channel 的区别，是否阻塞，读/写一个已关闭的 channel 会发生什么？

![image-20230325121556981](面试题.assets/image-20230325121556981.png)



介绍一下 GC 



介绍一下 GMP 模型   



defer  机制  

是一个延迟函数,常用于一些IO的关闭 是一个栈结构 先进后出



goroutine 和线程的区别  



**go 中如何限制 goroutine 的数量**  

答:使用channel 和sync.WaitGroup() ｛add() Done() wait()｝



go 中如何控制一个 goroutine  的退出  



讲一下 go 中的 context 

介绍一下 go 中的锁 

go 中有哪些数据是引用类型 

go 中的 interface 有什么用，判断 interface 是不是 nil 

设计模式